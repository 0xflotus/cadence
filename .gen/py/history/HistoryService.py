#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  HistoryService provides API to start a new long running workflow instance, as well as query and update the history
  of workflow instances already created.

  """
  def StartWorkflowExecution(self, startRequest):
    """
    StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
    'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
    first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
    exists with same workflowId.


    Parameters:
     - startRequest
    """
    pass

  def GetWorkflowExecutionHistory(self, getRequest):
    """
    Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
    execution in unknown to the service.


    Parameters:
     - getRequest
    """
    pass

  def RecordDecisionTaskStarted(self, addRequest):
    """
    RecordDecisionTaskStarted is called by the Matchingservice before it hands a decision task to the application worker in response to
    a PollForDecisionTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
    if the workflow's execution history already includes a record of the event starting.


    Parameters:
     - addRequest
    """
    pass

  def RecordActivityTaskStarted(self, addRequest):
    """
    RecordActivityTaskStarted is called by the Matchingservice before it hands a decision task to the application worker in response to
    a PollForActivityTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
    if the workflow's execution history already includes a record of the event starting.


    Parameters:
     - addRequest
    """
    pass

  def RespondDecisionTaskCompleted(self, completeRequest):
    """
    RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
    'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
    potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
    event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
    for completing the DecisionTask.


    Parameters:
     - completeRequest
    """
    pass

  def RecordActivityTaskHeartbeat(self, heartbeatRequest):
    """
    RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
    to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
    'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
    fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for heartbeating.


    Parameters:
     - heartbeatRequest
    """
    pass

  def RespondActivityTaskCompleted(self, completeRequest):
    """
    RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
    created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - completeRequest
    """
    pass

  def RespondActivityTaskFailed(self, failRequest):
    """
    RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - failRequest
    """
    pass

  def RespondActivityTaskCanceled(self, canceledRequest):
    """
    RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
    result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - canceledRequest
    """
    pass


class Client(Iface):
  """
  HistoryService provides API to start a new long running workflow instance, as well as query and update the history
  of workflow instances already created.

  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def StartWorkflowExecution(self, startRequest):
    """
    StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
    'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
    first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
    exists with same workflowId.


    Parameters:
     - startRequest
    """
    self.send_StartWorkflowExecution(startRequest)
    return self.recv_StartWorkflowExecution()

  def send_StartWorkflowExecution(self, startRequest):
    self._oprot.writeMessageBegin('StartWorkflowExecution', TMessageType.CALL, self._seqid)
    args = StartWorkflowExecution_args()
    args.startRequest = startRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_StartWorkflowExecution(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = StartWorkflowExecution_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.sessionAlreadyExistError is not None:
      raise result.sessionAlreadyExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "StartWorkflowExecution failed: unknown result");

  def GetWorkflowExecutionHistory(self, getRequest):
    """
    Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
    execution in unknown to the service.


    Parameters:
     - getRequest
    """
    self.send_GetWorkflowExecutionHistory(getRequest)
    return self.recv_GetWorkflowExecutionHistory()

  def send_GetWorkflowExecutionHistory(self, getRequest):
    self._oprot.writeMessageBegin('GetWorkflowExecutionHistory', TMessageType.CALL, self._seqid)
    args = GetWorkflowExecutionHistory_args()
    args.getRequest = getRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetWorkflowExecutionHistory(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetWorkflowExecutionHistory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkflowExecutionHistory failed: unknown result");

  def RecordDecisionTaskStarted(self, addRequest):
    """
    RecordDecisionTaskStarted is called by the Matchingservice before it hands a decision task to the application worker in response to
    a PollForDecisionTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
    if the workflow's execution history already includes a record of the event starting.


    Parameters:
     - addRequest
    """
    self.send_RecordDecisionTaskStarted(addRequest)
    return self.recv_RecordDecisionTaskStarted()

  def send_RecordDecisionTaskStarted(self, addRequest):
    self._oprot.writeMessageBegin('RecordDecisionTaskStarted', TMessageType.CALL, self._seqid)
    args = RecordDecisionTaskStarted_args()
    args.addRequest = addRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RecordDecisionTaskStarted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RecordDecisionTaskStarted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.eventAlreadyStartedError is not None:
      raise result.eventAlreadyStartedError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RecordDecisionTaskStarted failed: unknown result");

  def RecordActivityTaskStarted(self, addRequest):
    """
    RecordActivityTaskStarted is called by the Matchingservice before it hands a decision task to the application worker in response to
    a PollForActivityTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
    if the workflow's execution history already includes a record of the event starting.


    Parameters:
     - addRequest
    """
    self.send_RecordActivityTaskStarted(addRequest)
    return self.recv_RecordActivityTaskStarted()

  def send_RecordActivityTaskStarted(self, addRequest):
    self._oprot.writeMessageBegin('RecordActivityTaskStarted', TMessageType.CALL, self._seqid)
    args = RecordActivityTaskStarted_args()
    args.addRequest = addRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RecordActivityTaskStarted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RecordActivityTaskStarted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.eventAlreadyStartedError is not None:
      raise result.eventAlreadyStartedError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RecordActivityTaskStarted failed: unknown result");

  def RespondDecisionTaskCompleted(self, completeRequest):
    """
    RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
    'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
    potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
    event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
    for completing the DecisionTask.


    Parameters:
     - completeRequest
    """
    self.send_RespondDecisionTaskCompleted(completeRequest)
    self.recv_RespondDecisionTaskCompleted()

  def send_RespondDecisionTaskCompleted(self, completeRequest):
    self._oprot.writeMessageBegin('RespondDecisionTaskCompleted', TMessageType.CALL, self._seqid)
    args = RespondDecisionTaskCompleted_args()
    args.completeRequest = completeRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondDecisionTaskCompleted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondDecisionTaskCompleted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return

  def RecordActivityTaskHeartbeat(self, heartbeatRequest):
    """
    RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
    to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
    'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
    fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for heartbeating.


    Parameters:
     - heartbeatRequest
    """
    self.send_RecordActivityTaskHeartbeat(heartbeatRequest)
    return self.recv_RecordActivityTaskHeartbeat()

  def send_RecordActivityTaskHeartbeat(self, heartbeatRequest):
    self._oprot.writeMessageBegin('RecordActivityTaskHeartbeat', TMessageType.CALL, self._seqid)
    args = RecordActivityTaskHeartbeat_args()
    args.heartbeatRequest = heartbeatRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RecordActivityTaskHeartbeat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RecordActivityTaskHeartbeat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RecordActivityTaskHeartbeat failed: unknown result");

  def RespondActivityTaskCompleted(self, completeRequest):
    """
    RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
    created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - completeRequest
    """
    self.send_RespondActivityTaskCompleted(completeRequest)
    self.recv_RespondActivityTaskCompleted()

  def send_RespondActivityTaskCompleted(self, completeRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskCompleted', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskCompleted_args()
    args.completeRequest = completeRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskCompleted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskCompleted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return

  def RespondActivityTaskFailed(self, failRequest):
    """
    RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - failRequest
    """
    self.send_RespondActivityTaskFailed(failRequest)
    self.recv_RespondActivityTaskFailed()

  def send_RespondActivityTaskFailed(self, failRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskFailed', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskFailed_args()
    args.failRequest = failRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskFailed(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskFailed_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return

  def RespondActivityTaskCanceled(self, canceledRequest):
    """
    RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
    result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - canceledRequest
    """
    self.send_RespondActivityTaskCanceled(canceledRequest)
    self.recv_RespondActivityTaskCanceled()

  def send_RespondActivityTaskCanceled(self, canceledRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskCanceled', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskCanceled_args()
    args.canceledRequest = canceledRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskCanceled(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskCanceled_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["StartWorkflowExecution"] = Processor.process_StartWorkflowExecution
    self._processMap["GetWorkflowExecutionHistory"] = Processor.process_GetWorkflowExecutionHistory
    self._processMap["RecordDecisionTaskStarted"] = Processor.process_RecordDecisionTaskStarted
    self._processMap["RecordActivityTaskStarted"] = Processor.process_RecordActivityTaskStarted
    self._processMap["RespondDecisionTaskCompleted"] = Processor.process_RespondDecisionTaskCompleted
    self._processMap["RecordActivityTaskHeartbeat"] = Processor.process_RecordActivityTaskHeartbeat
    self._processMap["RespondActivityTaskCompleted"] = Processor.process_RespondActivityTaskCompleted
    self._processMap["RespondActivityTaskFailed"] = Processor.process_RespondActivityTaskFailed
    self._processMap["RespondActivityTaskCanceled"] = Processor.process_RespondActivityTaskCanceled

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_StartWorkflowExecution(self, seqid, iprot, oprot):
    args = StartWorkflowExecution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = StartWorkflowExecution_result()
    try:
      result.success = self._handler.StartWorkflowExecution(args.startRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.WorkflowExecutionAlreadyStartedError, sessionAlreadyExistError:
      result.sessionAlreadyExistError = sessionAlreadyExistError
    oprot.writeMessageBegin("StartWorkflowExecution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetWorkflowExecutionHistory(self, seqid, iprot, oprot):
    args = GetWorkflowExecutionHistory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetWorkflowExecutionHistory_result()
    try:
      result.success = self._handler.GetWorkflowExecutionHistory(args.getRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("GetWorkflowExecutionHistory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RecordDecisionTaskStarted(self, seqid, iprot, oprot):
    args = RecordDecisionTaskStarted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RecordDecisionTaskStarted_result()
    try:
      result.success = self._handler.RecordDecisionTaskStarted(args.addRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except EventAlreadyStartedError, eventAlreadyStartedError:
      result.eventAlreadyStartedError = eventAlreadyStartedError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RecordDecisionTaskStarted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RecordActivityTaskStarted(self, seqid, iprot, oprot):
    args = RecordActivityTaskStarted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RecordActivityTaskStarted_result()
    try:
      result.success = self._handler.RecordActivityTaskStarted(args.addRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except EventAlreadyStartedError, eventAlreadyStartedError:
      result.eventAlreadyStartedError = eventAlreadyStartedError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RecordActivityTaskStarted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondDecisionTaskCompleted(self, seqid, iprot, oprot):
    args = RespondDecisionTaskCompleted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondDecisionTaskCompleted_result()
    try:
      self._handler.RespondDecisionTaskCompleted(args.completeRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondDecisionTaskCompleted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RecordActivityTaskHeartbeat(self, seqid, iprot, oprot):
    args = RecordActivityTaskHeartbeat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RecordActivityTaskHeartbeat_result()
    try:
      result.success = self._handler.RecordActivityTaskHeartbeat(args.heartbeatRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RecordActivityTaskHeartbeat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskCompleted(self, seqid, iprot, oprot):
    args = RespondActivityTaskCompleted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskCompleted_result()
    try:
      self._handler.RespondActivityTaskCompleted(args.completeRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskCompleted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskFailed(self, seqid, iprot, oprot):
    args = RespondActivityTaskFailed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskFailed_result()
    try:
      self._handler.RespondActivityTaskFailed(args.failRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskFailed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskCanceled(self, seqid, iprot, oprot):
    args = RespondActivityTaskCanceled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskCanceled_result()
    try:
      self._handler.RespondActivityTaskCanceled(args.canceledRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskCanceled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class StartWorkflowExecution_args:
  """
  Attributes:
   - startRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'startRequest', (shared.ttypes.StartWorkflowExecutionRequest, shared.ttypes.StartWorkflowExecutionRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, startRequest=None,):
    self.startRequest = startRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.startRequest = shared.ttypes.StartWorkflowExecutionRequest()
          self.startRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartWorkflowExecution_args')
    if self.startRequest is not None:
      oprot.writeFieldBegin('startRequest', TType.STRUCT, 1)
      self.startRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartWorkflowExecution_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - sessionAlreadyExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.StartWorkflowExecutionResponse, shared.ttypes.StartWorkflowExecutionResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sessionAlreadyExistError', (shared.ttypes.WorkflowExecutionAlreadyStartedError, shared.ttypes.WorkflowExecutionAlreadyStartedError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, sessionAlreadyExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.sessionAlreadyExistError = sessionAlreadyExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.StartWorkflowExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sessionAlreadyExistError = shared.ttypes.WorkflowExecutionAlreadyStartedError()
          self.sessionAlreadyExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartWorkflowExecution_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.sessionAlreadyExistError is not None:
      oprot.writeFieldBegin('sessionAlreadyExistError', TType.STRUCT, 3)
      self.sessionAlreadyExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.sessionAlreadyExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkflowExecutionHistory_args:
  """
  Attributes:
   - getRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (shared.ttypes.GetWorkflowExecutionHistoryRequest, shared.ttypes.GetWorkflowExecutionHistoryRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, getRequest=None,):
    self.getRequest = getRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = shared.ttypes.GetWorkflowExecutionHistoryRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkflowExecutionHistory_args')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkflowExecutionHistory_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.GetWorkflowExecutionHistoryResponse, shared.ttypes.GetWorkflowExecutionHistoryResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.GetWorkflowExecutionHistoryResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkflowExecutionHistory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordDecisionTaskStarted_args:
  """
  Attributes:
   - addRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'addRequest', (RecordDecisionTaskStartedRequest, RecordDecisionTaskStartedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, addRequest=None,):
    self.addRequest = addRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.addRequest = RecordDecisionTaskStartedRequest()
          self.addRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordDecisionTaskStarted_args')
    if self.addRequest is not None:
      oprot.writeFieldBegin('addRequest', TType.STRUCT, 1)
      self.addRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.addRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordDecisionTaskStarted_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - eventAlreadyStartedError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RecordDecisionTaskStartedResponse, RecordDecisionTaskStartedResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'eventAlreadyStartedError', (EventAlreadyStartedError, EventAlreadyStartedError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, eventAlreadyStartedError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.eventAlreadyStartedError = eventAlreadyStartedError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RecordDecisionTaskStartedResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.eventAlreadyStartedError = EventAlreadyStartedError()
          self.eventAlreadyStartedError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordDecisionTaskStarted_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.eventAlreadyStartedError is not None:
      oprot.writeFieldBegin('eventAlreadyStartedError', TType.STRUCT, 3)
      self.eventAlreadyStartedError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 4)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.eventAlreadyStartedError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskStarted_args:
  """
  Attributes:
   - addRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'addRequest', (RecordActivityTaskStartedRequest, RecordActivityTaskStartedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, addRequest=None,):
    self.addRequest = addRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.addRequest = RecordActivityTaskStartedRequest()
          self.addRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskStarted_args')
    if self.addRequest is not None:
      oprot.writeFieldBegin('addRequest', TType.STRUCT, 1)
      self.addRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.addRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskStarted_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - eventAlreadyStartedError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RecordActivityTaskStartedResponse, RecordActivityTaskStartedResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'eventAlreadyStartedError', (EventAlreadyStartedError, EventAlreadyStartedError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, eventAlreadyStartedError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.eventAlreadyStartedError = eventAlreadyStartedError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RecordActivityTaskStartedResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.eventAlreadyStartedError = EventAlreadyStartedError()
          self.eventAlreadyStartedError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskStarted_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.eventAlreadyStartedError is not None:
      oprot.writeFieldBegin('eventAlreadyStartedError', TType.STRUCT, 3)
      self.eventAlreadyStartedError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 4)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.eventAlreadyStartedError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondDecisionTaskCompleted_args:
  """
  Attributes:
   - completeRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'completeRequest', (shared.ttypes.RespondDecisionTaskCompletedRequest, shared.ttypes.RespondDecisionTaskCompletedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, completeRequest=None,):
    self.completeRequest = completeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.completeRequest = shared.ttypes.RespondDecisionTaskCompletedRequest()
          self.completeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondDecisionTaskCompleted_args')
    if self.completeRequest is not None:
      oprot.writeFieldBegin('completeRequest', TType.STRUCT, 1)
      self.completeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.completeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondDecisionTaskCompleted_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondDecisionTaskCompleted_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskHeartbeat_args:
  """
  Attributes:
   - heartbeatRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'heartbeatRequest', (shared.ttypes.RecordActivityTaskHeartbeatRequest, shared.ttypes.RecordActivityTaskHeartbeatRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, heartbeatRequest=None,):
    self.heartbeatRequest = heartbeatRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.heartbeatRequest = shared.ttypes.RecordActivityTaskHeartbeatRequest()
          self.heartbeatRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskHeartbeat_args')
    if self.heartbeatRequest is not None:
      oprot.writeFieldBegin('heartbeatRequest', TType.STRUCT, 1)
      self.heartbeatRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.heartbeatRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskHeartbeat_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.RecordActivityTaskHeartbeatResponse, shared.ttypes.RecordActivityTaskHeartbeatResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.RecordActivityTaskHeartbeatResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskHeartbeat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCompleted_args:
  """
  Attributes:
   - completeRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'completeRequest', (shared.ttypes.RespondActivityTaskCompletedRequest, shared.ttypes.RespondActivityTaskCompletedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, completeRequest=None,):
    self.completeRequest = completeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.completeRequest = shared.ttypes.RespondActivityTaskCompletedRequest()
          self.completeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCompleted_args')
    if self.completeRequest is not None:
      oprot.writeFieldBegin('completeRequest', TType.STRUCT, 1)
      self.completeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.completeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCompleted_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCompleted_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskFailed_args:
  """
  Attributes:
   - failRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'failRequest', (shared.ttypes.RespondActivityTaskFailedRequest, shared.ttypes.RespondActivityTaskFailedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, failRequest=None,):
    self.failRequest = failRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.failRequest = shared.ttypes.RespondActivityTaskFailedRequest()
          self.failRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskFailed_args')
    if self.failRequest is not None:
      oprot.writeFieldBegin('failRequest', TType.STRUCT, 1)
      self.failRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.failRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskFailed_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskFailed_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCanceled_args:
  """
  Attributes:
   - canceledRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'canceledRequest', (shared.ttypes.RespondActivityTaskCanceledRequest, shared.ttypes.RespondActivityTaskCanceledRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, canceledRequest=None,):
    self.canceledRequest = canceledRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.canceledRequest = shared.ttypes.RespondActivityTaskCanceledRequest()
          self.canceledRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCanceled_args')
    if self.canceledRequest is not None:
      oprot.writeFieldBegin('canceledRequest', TType.STRUCT, 1)
      self.canceledRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.canceledRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCanceled_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCanceled_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
