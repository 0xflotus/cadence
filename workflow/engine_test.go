package workflow

import (
	"encoding/json"
	"errors"
	"os"
	"testing"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"github.com/uber-common/bark"

	workflow "code.uber.internal/devexp/minions/.gen/go/minions"
	"code.uber.internal/devexp/minions/common"
)

type (
	engineSuite struct {
		suite.Suite
		WorkflowTestBase
		engine           WorkflowEngine
		builder          *historyBuilder
		mockEngine       *EngineImpl
		mockTaskMgr      *mockTaskPersistence
		mockExecutionMgr *mockWorkflowExecutionPersistence
		logger           bark.Logger
	}
)

func TestEngineSuite(t *testing.T) {
	s := new(engineSuite)
	suite.Run(t, s)
}

func (s *engineSuite) SetupSuite() {
	if testing.Verbose() {
		log.SetOutput(os.Stdout)
	}

	s.setupWorkflowStore()
	s.engine = NewWorkflowEngine(s.WorkflowMgr, s.TaskMgr, bark.NewLoggerFromLogrus(log.New()))

	s.logger = bark.NewLoggerFromLogrus(log.New())
	s.builder = newHistoryBuilder(s.logger)
}

func (s *engineSuite) TearDownSuite() {
	s.tearDownWorkflowStore()
}

func (s *engineSuite) SetupTest() {
	s.mockTaskMgr = &mockTaskPersistence{}
	s.mockExecutionMgr = &mockWorkflowExecutionPersistence{}

	s.mockEngine = &EngineImpl{
		executionManager: s.mockExecutionMgr,
		taskManager:      s.mockTaskMgr,
		txProcessor:      newTransferQueueProcessor(s.mockExecutionMgr, s.mockTaskMgr, s.logger),
		logger:           s.logger,
		tokenSerializer:  newJSONTaskTokenSerializer(),
	}
}

func (s *engineSuite) TearDownTest() {
	s.mockTaskMgr.AssertExpectations(s.T())
	s.mockExecutionMgr.AssertExpectations(s.T())
}

func (s *engineSuite) TestStartWorkflowExecution() {
	id := "engine-start-workflow-test"
	wt := "engine-start-workflow-test-type"
	tl := "engine-start-workflow-test-tasklist"
	identity := "worker1"

	workflowType := workflow.NewWorkflowType()
	workflowType.Name = common.StringPtr(wt)

	taskList := workflow.NewTaskList()
	taskList.Name = common.StringPtr(tl)

	request := &workflow.StartWorkflowExecutionRequest{
		WorkflowId:   common.StringPtr(id),
		WorkflowType: workflowType,
		TaskList:     taskList,
		Input:        nil,
		ExecutionStartToCloseTimeoutSeconds: common.Int32Ptr(100),
		TaskStartToCloseTimeoutSeconds:      common.Int32Ptr(1),
		Identity:                            common.StringPtr(identity),
	}

	we0, err0 := s.engine.StartWorkflowExecution(request)
	s.Nil(err0)
	s.Equal(id, we0.GetWorkflowId())

	we1, err1 := s.engine.StartWorkflowExecution(request)
	s.NotNil(err1)
	s.IsType(workflow.NewWorkflowExecutionAlreadyStartedError(), err1)
	log.Infof("Start workflow execution failed with error: %v", err1.Error())
	s.Empty(we1.GetWorkflowId())
	s.Empty(we1.GetRunId())
}

// mockTaskPersistence is an autogenerated mock type for the taskPersistence type
type mockTaskPersistence struct {
	mock.Mock
}

// CompleteTask provides a mock function with given fields: request
func (_m *mockTaskPersistence) CompleteTask(request *completeTaskRequest) error {
	ret := _m.Called(request)

	var r0 error
	if rf, ok := ret.Get(0).(func(*completeTaskRequest) error); ok {
		r0 = rf(request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTask provides a mock function with given fields: request
// Need to export dataInterfaces in order to move to mocks folder.
func (_m *mockTaskPersistence) CreateTask(request *createTaskRequest) (*createTaskResponse, error) {
	ret := _m.Called(request)

	var r0 *createTaskResponse
	if rf, ok := ret.Get(0).(func(*createTaskRequest) *createTaskResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*createTaskResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*createTaskRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTasks provides a mock function with given fields: request
func (_m *mockTaskPersistence) GetTasks(request *getTasksRequest) (*getTasksResponse, error) {
	ret := _m.Called(request)

	var r0 *getTasksResponse
	if rf, ok := ret.Get(0).(func(*getTasksRequest) *getTasksResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*getTasksResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*getTasksRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockWorkflowExecutionPersistence is an autogenerated mock type for the workflowExecutionPersistence type
type mockWorkflowExecutionPersistence struct {
	mock.Mock
}

// CompleteTransferTask provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) CompleteTransferTask(request *completeTransferTaskRequest) error {
	ret := _m.Called(request)

	var r0 error
	if rf, ok := ret.Get(0).(func(*completeTransferTaskRequest) error); ok {
		r0 = rf(request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateWorkflowExecution provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) CreateWorkflowExecution(request *createWorkflowExecutionRequest) (*createWorkflowExecutionResponse, error) {
	ret := _m.Called(request)

	var r0 *createWorkflowExecutionResponse
	if rf, ok := ret.Get(0).(func(*createWorkflowExecutionRequest) *createWorkflowExecutionResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*createWorkflowExecutionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*createWorkflowExecutionRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflowExecution provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) DeleteWorkflowExecution(request *deleteWorkflowExecutionRequest) error {
	ret := _m.Called(request)

	var r0 error
	if rf, ok := ret.Get(0).(func(*deleteWorkflowExecutionRequest) error); ok {
		r0 = rf(request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetTransferTasks provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) GetTransferTasks(request *getTransferTasksRequest) (*getTransferTasksResponse, error) {
	ret := _m.Called(request)

	var r0 *getTransferTasksResponse
	if rf, ok := ret.Get(0).(func(*getTransferTasksRequest) *getTransferTasksResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*getTransferTasksResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*getTransferTasksRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowExecution provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) GetWorkflowExecution(request *getWorkflowExecutionRequest) (*getWorkflowExecutionResponse, error) {
	ret := _m.Called(request)

	var r0 *getWorkflowExecutionResponse
	if rf, ok := ret.Get(0).(func(*getWorkflowExecutionRequest) *getWorkflowExecutionResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*getWorkflowExecutionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*getWorkflowExecutionRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflowExecution provides a mock function with given fields: request
func (_m *mockWorkflowExecutionPersistence) UpdateWorkflowExecution(request *updateWorkflowExecutionRequest) error {
	ret := _m.Called(request)

	var r0 error
	if rf, ok := ret.Get(0).(func(*updateWorkflowExecutionRequest) error); ok {
		r0 = rf(request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

func (s *engineSuite) TestPollForActivityTasks() {
	tl := "makeToast"
	identity := "selfDrivingToaster"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{taskList: tl, taskType: taskTypeActivity, lockTimeout: taskLockDuration, batchSize: 1}

	// There are no tasks
	s.mockTaskMgr.On("GetTasks", taskRequest).Return(&getTasksResponse{}, nil).Once()
	_, err := s.mockEngine.pollForActivityTaskOperation(&workflow.PollForActivityTaskRequest{
		TaskList: taskList,
		Identity: &identity})
	s.Equal(errNoTasks, err)
	s.mockTaskMgr.AssertExpectations(s.T())
	s.mockExecutionMgr.AssertExpectations(s.T())

	// Can't get tasks
	s.mockTaskMgr.On("GetTasks", taskRequest).Return(nil, errors.New("Out of bread")).Once()
	_, err = s.mockEngine.PollForActivityTask(&workflow.PollForActivityTaskRequest{
		TaskList: taskList,
		Identity: &identity})
	s.EqualError(err, "Out of bread")
	s.mockTaskMgr.AssertExpectations(s.T())
	s.mockExecutionMgr.AssertExpectations(s.T())

	// Lets do something
	resp := &getTasksResponse{tasks: []*taskInfo{{"wId", "rId", "tId", tl, 1, 1 + firstEventID, time.Time{}, "lock", 0}}}
	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	scheduledEvent := builder.AddDecisionTaskScheduledEvent(tl, 2)
	actType := workflow.NewActivityType()
	actType.Name = common.StringPtr("Dynamic type")

	builder.AddActivityTaskScheduledEvent(*scheduledEvent.EventId,
		&workflow.ScheduleActivityTaskDecisionAttributes{
			ActivityId:   common.StringPtr("Very unique id"),
			ActivityType: actType,
			Input:        []byte{9, 8, 7},
		})

	history, err := builder.Serialize()
	s.Nil(err)

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(resp, nil).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(
		&getWorkflowExecutionResponse{
			executionInfo: &workflowExecutionInfo{"wId", "rId", "tId", history, nil, 3, 1, 0, time.Time{}, false},
		},
		nil).Once()

	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()
	task, err := s.mockEngine.PollForActivityTask(&workflow.PollForActivityTaskRequest{
		TaskList: taskList,
		Identity: &identity})
	s.Nil(err)
	s.Equal("Very unique id", task.GetActivityId())
	s.Equal([]byte{9, 8, 7}, task.GetInput())
	s.Equal(actType, task.GetActivityType())

	var updateRequest *updateWorkflowExecutionRequest
	ok := false
	if updateRequest, ok = s.mockExecutionMgr.Calls[len(s.mockExecutionMgr.Calls)-1].Arguments[0].(*updateWorkflowExecutionRequest); !ok {
		s.Fail("Wrong parameter type was passed to UpdateWorkflowExecution")
	}

	// Examine history
	updatedHistory, err := newJSONHistorySerializer().Deserialize(updateRequest.executionInfo.history)
	s.Nil(err)

	// We should have 3 events: Decision, ScheduledTask and StartedTask
	s.Equal(3, len(updatedHistory))
	s.Equal(0, len(updateRequest.transferTasks))

}

func (s *engineSuite) TestPollForActivityTasksIfTaskAlreadyStarted() {
	id := "TestPollForActivityTasksIfTaskAlreadyStarted"
	wt := "UT"
	tl := "makeBreakfast"
	identity := "mickey mouse"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl
	workflowType := workflow.NewWorkflowType()
	workflowType.Name = common.StringPtr(wt)

	taskRequest := &getTasksRequest{taskList: "makeBreakfast", taskType: 1, lockTimeout: taskLockDuration, batchSize: 1}

	resp := &getTasksResponse{tasks: []*taskInfo{{"wId", "rId", "tId", tl, 1, 2 + firstEventID, time.Time{}, "lock", 0}}}
	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))

	request := &workflow.StartWorkflowExecutionRequest{
		WorkflowId:   common.StringPtr(id),
		WorkflowType: workflowType,
		TaskList:     taskList,
		Input:        nil,
		ExecutionStartToCloseTimeoutSeconds: common.Int32Ptr(100),
		TaskStartToCloseTimeoutSeconds:      common.Int32Ptr(1),
		Identity:                            common.StringPtr(identity),
	}

	builder.AddWorkflowExecutionStartedEvent(request)
	scheduledEvent := builder.AddDecisionTaskScheduledEvent(tl, 2)

	taskScheduled := builder.AddActivityTaskScheduledEvent(*scheduledEvent.EventId, &workflow.ScheduleActivityTaskDecisionAttributes{})
	started := builder.AddActivityTaskStartedEvent(*taskScheduled.EventId, &workflow.PollForActivityTaskRequest{TaskList: taskList, Identity: &identity})
	history, err := builder.Serialize()
	s.Nil(err)

	// Fail GetWorkflowExecution first time and pass on the retry.
	s.mockTaskMgr.On("GetTasks", taskRequest).Return(resp, nil).Twice()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Twice()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, errors.New("Let's get dangerous!")).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(
		&getWorkflowExecutionResponse{
			executionInfo: &workflowExecutionInfo{"wId", "rId", "tId", history, nil, 3, builder.nextEventID, *started.EventId, time.Time{}, false},
		},
		nil).Once()

	activityTasks, err := s.mockEngine.pollForActivityTaskOperation(&workflow.PollForActivityTaskRequest{
		TaskList: taskList,
		Identity: &identity})
	s.EqualError(err, "Let's get dangerous!")

	activityTasks, err = s.mockEngine.pollForActivityTaskOperation(&workflow.PollForActivityTaskRequest{
		TaskList: taskList,
		Identity: &identity})
	s.Equal(err, errDuplicate)

	s.Equal((*workflow.PollForActivityTaskResponse)(nil), activityTasks)
}

func (s *engineSuite) TestPollForActivityTasksOnConditionalUpdateFail() {
	tl := "drawMickey"
	identity := "Disney"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{taskList: tl, taskType: 1, lockTimeout: taskLockDuration, batchSize: 1}

	resp := &getTasksResponse{tasks: []*taskInfo{{"wId", "rId", "tId", tl, 1, 1 + firstEventID, time.Time{}, "lock", 0}}}
	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	scheduledEvent := builder.AddDecisionTaskScheduledEvent(tl, 2)

	activity := workflow.NewScheduleActivityTaskDecisionAttributes()
	activity.ActivityType = workflow.NewActivityType()
	activity.ActivityType.Name = common.StringPtr("draw head")
	activity.Input = []byte{1, 2, 3}

	s.NotNil(builder.AddActivityTaskScheduledEvent(*scheduledEvent.EventId, activity))
	history, err := builder.Serialize()
	s.Nil(err)

	// Get tasks and wf execution.
	s.mockTaskMgr.On("GetTasks", taskRequest).Return(resp, nil).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(
		&getWorkflowExecutionResponse{
			executionInfo: &workflowExecutionInfo{"wId", "rId", "tId", history, nil, 3, 1, 0, time.Time{}, false},
		},
		nil).Once()

	// Someone added a new activity

	s.NotNil(builder.AddActivityTaskScheduledEvent(*scheduledEvent.EventId, workflow.NewScheduleActivityTaskDecisionAttributes()))
	history, err = builder.Serialize()
	s.Nil(err)

	// Fail update
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()

	// Receive an updated execution and complete it
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(
		&getWorkflowExecutionResponse{
			executionInfo: &workflowExecutionInfo{"wId", "rId", "tId", history, nil, 3, 1, 0, time.Time{}, false},
		},
		nil).Once()

	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	task, err := s.mockEngine.pollForActivityTaskOperation(&workflow.PollForActivityTaskRequest{TaskList: taskList, Identity: &identity})
	s.Nil(err)
	s.Equal("draw head", task.GetActivityType().GetName())
	s.Equal([]byte{1, 2, 3}, task.Input)
	var updateRequest *updateWorkflowExecutionRequest
	ok := false
	if updateRequest, ok = s.mockExecutionMgr.Calls[len(s.mockExecutionMgr.Calls)-1].Arguments[0].(*updateWorkflowExecutionRequest); !ok {
		s.Fail("Wrong parameter type was passed to UpdateWorkflowExecution")
	}

	// Examine history
	updatedHistory, err := newJSONHistorySerializer().Deserialize(updateRequest.executionInfo.history)
	s.Nil(err)

	// We should have 4 events: Decision, ScheduledTask and 2 StartedTasks
	s.Equal(4, len(updatedHistory))
	s.Equal(0, len(updateRequest.transferTasks))
}

func (s *engineSuite) TestPollForDecisionTasksNoTasks() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(&getTasksResponse{}, nil)

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.Equal(errNoTasks, err)
}

func (s *engineSuite) TestPollForDecisionTasksIfGetTaskFailed() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(nil, errors.New("Failed!!!"))

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.EqualError(err, "Failed!!!")
}

func (s *engineSuite) TestPollForDecisionTasksIfNoExecution() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, 2, time.Time{}, "lock", 0}},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, &workflow.EntityNotExistsError{}).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestPollForDecisionTasksIfTaskAlreadyStarted() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)
	history, _ := builder.Serialize()

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, scheduleEvent.GetEventId(), time.Time{}, "lock", 0}},
	}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.Equal(errDuplicate, err)
}

func (s *engineSuite) TestPollForDecisionTasksIfTaskAlreadyCompleted() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	startedEvent := addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)
	addDecisionTaskCompletedEvent(builder, scheduleEvent.GetEventId(), startedEvent.GetEventId(), nil, identity)

	history, _ := builder.Serialize()

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, scheduleEvent.GetEventId(), time.Time{}, "lock", 0}},
	}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.Equal(errDuplicate, err)
}

func (s *engineSuite) TestPollForDecisionTasksConflict() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	history, _ := builder.Serialize()

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, scheduleEvent.GetEventId(), time.Time{}, "lock", 0}},
	}
	wfResponse1 := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}
	wfResponse2 := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse1, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse2, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	task, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.Nil(err)
	s.NotNil(task)
	s.NotEmpty(task.GetTaskToken())
	s.Equal("wId", task.GetWorkflowExecution().GetWorkflowId())
	s.Equal("rId", task.GetWorkflowExecution().GetRunId())
	s.Equal("wType", task.GetWorkflowType().GetName())
	s.False(task.IsSetPreviousStartedEventId())
	s.Equal(scheduleEvent.GetEventId()+1, task.GetStartedEventId())
	s.NotEmpty(task.GetHistory())
}

func (s *engineSuite) TestPollForDecisionTasksMaxAttemptsExceeded() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	history, _ := builder.Serialize()

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, scheduleEvent.GetEventId(), time.Time{}, "lock", 0}},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	for i := 0; i < conditionalRetryCount; i++ {
		s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(&getWorkflowExecutionResponse{
			executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
				emptyEventID, time.Time{}, true},
		}, nil).Once()
	}
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).
		Times(conditionalRetryCount)
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	_, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.NotNil(err)
	s.Equal(errMaxAttemptsExceeded, err)
}

func (s *engineSuite) TestPollForDecisionTasksSuccess() {
	tl := "testTaskList"
	identity := "testIdentity"

	taskList := workflow.NewTaskList()
	taskList.Name = &tl

	taskRequest := &getTasksRequest{
		taskList:    tl,
		taskType:    taskTypeDecision,
		lockTimeout: taskLockDuration,
		batchSize:   1,
	}

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	history, _ := builder.Serialize()

	taskResponse := &getTasksResponse{
		tasks: []*taskInfo{{"wId", "rId", "tId", tl, taskTypeDecision, scheduleEvent.GetEventId(), time.Time{}, "lock", 0}},
	}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockTaskMgr.On("GetTasks", taskRequest).Return(taskResponse, nil)
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockTaskMgr.On("CompleteTask", mock.Anything).Return(nil).Once()

	task, err := s.mockEngine.pollForDecisionTaskOperation(&workflow.PollForDecisionTaskRequest{
		TaskList: taskList,
		Identity: &identity,
	})
	s.Nil(err)
	s.NotNil(task)
	s.NotEmpty(task.GetTaskToken())
	s.Equal("wId", task.GetWorkflowExecution().GetWorkflowId())
	s.Equal("rId", task.GetWorkflowExecution().GetRunId())
	s.Equal("wType", task.GetWorkflowType().GetName())
	s.False(task.IsSetPreviousStartedEventId())
	s.Equal(scheduleEvent.GetEventId()+1, task.GetStartedEventId())
	s.NotEmpty(task.GetHistory())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedInvalidToken() {
	invalidToken, _ := json.Marshal("bad token")
	identity := "testIdentity"

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        invalidToken,
		Decisions:        nil,
		ExecutionContext: nil,
		Identity:         &identity,
	})

	s.NotNil(err)
	s.IsType(&workflow.BadRequestError{}, err)
}

func (s *engineSuite) TestRespondDecisionTaskCompletedIfNoExecution() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, &workflow.EntityNotExistsError{}).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondDecisionTaskCompletedIfGetExecutionFailed() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, errors.New("FAILED")).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondDecisionTaskCompletedUpdateExecutionFailed() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(errors.New("FAILED")).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondDecisionTaskCompletedIfTaskCompleted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	startedEvent := addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)
	addDecisionTaskCompletedEvent(builder, scheduleEvent.GetEventId(), startedEvent.GetEventId(), nil, identity)

	history, _ := builder.Serialize()
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondDecisionTaskCompletedIfTaskNotStarted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	addDecisionTaskScheduledEvent(builder, tl, 100)

	history, _ := builder.Serialize()
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondDecisionTaskCompletedConflictOnUpdate() {
	tl := "testTaskList"
	identity := "testIdentity"
	context := []byte("context")
	activity1ID := "activity1"
	activity1Type := "activity_type1"
	activity1Input := []byte("input1")
	activity1Result := []byte("activity1_result")
	activity2ID := "activity2"
	activity2Type := "activity_type2"
	activity2Input := []byte("input2")
	activity2Result := []byte("activity2_result")
	activity3ID := "activity3"
	activity3Type := "activity_type3"
	activity3Input := []byte("input3")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 25, 200, identity)
	decisionScheduledEvent1 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent1 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent1.GetEventId(), tl, identity)
	decisionCompletedEvent1 := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent1.GetEventId(),
		decisionStartedEvent1.GetEventId(), nil, identity)
	activity1ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity1ID,
		activity1Type, tl, activity1Input, 100, 10, 5)
	activity2ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity2ID,
		activity2Type, tl, activity2Input, 100, 10, 5)
	activity1StartedEvent := addActivityTaskStartedEvent(builder, activity1ScheduledEvent.GetEventId(), tl, identity)
	activity2StartedEvent := addActivityTaskStartedEvent(builder, activity2ScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskCompletedEvent(builder, activity1ScheduledEvent.GetEventId(),
		activity1StartedEvent.GetEventId(), activity1Result, identity)
	decisionScheduledEvent2 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent2 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent2.GetEventId(), tl, identity)

	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: decisionScheduledEvent2.GetEventId(),
	})

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_ScheduleActivityTask),
		ScheduleActivityTaskDecisionAttributes: &workflow.ScheduleActivityTaskDecisionAttributes{
			ActivityId:   common.StringPtr(activity3ID),
			ActivityType: &workflow.ActivityType{Name: common.StringPtr(activity3Type)},
			TaskList:     &workflow.TaskList{Name: &tl},
			Input:        activity3Input,
			ScheduleToCloseTimeoutSeconds: common.Int32Ptr(100),
			ScheduleToStartTimeoutSeconds: common.Int32Ptr(10),
			StartToCloseTimeoutSeconds:    common.Int32Ptr(50),
			HeartbeatTimeoutSeconds:       common.Int32Ptr(5),
		},
	}}

	history, _ := builder.Serialize()
	info1 := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse1 := &getWorkflowExecutionResponse{
		executionInfo: info1,
	}

	addActivityTaskCompletedEvent(builder, activity2ScheduledEvent.GetEventId(),
		activity2StartedEvent.GetEventId(), activity2Result, identity)
	history2, _ := builder.Serialize()
	info2 := &workflowExecutionInfo{"wId", "rId", tl, history2, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse2 := &getWorkflowExecutionResponse{
		executionInfo: info2,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse1, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse2, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err, string(history))
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info2)
	s.Equal(int64(16), info2.nextEventID)
	s.Equal(decisionStartedEvent2.GetEventId(), info2.lastProcessedEvent)
	s.Equal(context, info2.executionContext)

	completedEvent := updatedBuilder.GetEvent(13)
	s.Equal(decisionScheduledEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(decisionStartedEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	activity3Attributes := updatedBuilder.GetEvent(14).GetActivityTaskScheduledEventAttributes()
	s.Equal(activity3ID, activity3Attributes.GetActivityId())
	s.Equal(activity3Type, activity3Attributes.GetActivityType().GetName())
	s.Equal(completedEvent.GetEventId(), activity3Attributes.GetDecisionTaskCompletedEventId())
	s.Equal(tl, activity3Attributes.GetTaskList().GetName())
	s.Equal(activity3Input, activity3Attributes.GetInput())
	s.Equal(int32(100), activity3Attributes.GetScheduleToCloseTimeoutSeconds())
	s.Equal(int32(10), activity3Attributes.GetScheduleToStartTimeoutSeconds())
	s.Equal(int32(50), activity3Attributes.GetStartToCloseTimeoutSeconds())
	s.Equal(int32(5), activity3Attributes.GetHeartbeatTimeoutSeconds())

	decisionScheduledEventAttributes := updatedBuilder.GetEvent(15).GetDecisionTaskScheduledEventAttributes()
	s.Equal(tl, decisionScheduledEventAttributes.GetTaskList().GetName())
	s.Equal(int32(200), decisionScheduledEventAttributes.GetStartToCloseTimeoutSeconds())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedMaxAttemptsExceeded() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"
	context := []byte("context")
	input := []byte("input")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_ScheduleActivityTask),
		ScheduleActivityTaskDecisionAttributes: &workflow.ScheduleActivityTaskDecisionAttributes{
			ActivityId:   common.StringPtr("activity1"),
			ActivityType: &workflow.ActivityType{Name: common.StringPtr("activity_type1")},
			TaskList:     &workflow.TaskList{Name: &tl},
			Input:        input,
			ScheduleToCloseTimeoutSeconds: common.Int32Ptr(100),
			ScheduleToStartTimeoutSeconds: common.Int32Ptr(10),
			StartToCloseTimeoutSeconds:    common.Int32Ptr(50),
			HeartbeatTimeoutSeconds:       common.Int32Ptr(5),
		},
	}}

	history, _ := builder.Serialize()
	for i := 0; i < conditionalRetryCount; i++ {
		info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true}
		wfResponse := &getWorkflowExecutionResponse{
			executionInfo: info,
		}
		s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
		s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	}

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.NotNil(err)
	s.Equal(errMaxAttemptsExceeded, err)
}

func (s *engineSuite) TestRespondDecisionTaskCompletedCompleteWorkflowFailed() {
	tl := "testTaskList"
	identity := "testIdentity"
	context := []byte("context")
	activity1ID := "activity1"
	activity1Type := "activity_type1"
	activity1Input := []byte("input1")
	activity1Result := []byte("activity1_result")
	activity2ID := "activity2"
	activity2Type := "activity_type2"
	activity2Input := []byte("input2")
	workflowResult := []byte("workflow result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 25, 200, identity)
	decisionScheduledEvent1 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent1 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent1.GetEventId(), tl, identity)
	decisionCompletedEvent1 := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent1.GetEventId(),
		decisionStartedEvent1.GetEventId(), nil, identity)
	activity1ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity1ID,
		activity1Type, tl, activity1Input, 100, 10, 5)
	activity2ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity2ID,
		activity2Type, tl, activity2Input, 100, 10, 5)
	activity1StartedEvent := addActivityTaskStartedEvent(builder, activity1ScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskStartedEvent(builder, activity2ScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskCompletedEvent(builder, activity1ScheduledEvent.GetEventId(),
		activity1StartedEvent.GetEventId(), activity1Result, identity)
	decisionScheduledEvent2 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent2 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent2.GetEventId(), tl, identity)

	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: decisionScheduledEvent2.GetEventId(),
	})

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_CompleteWorkflowExecution),
		CompleteWorkflowExecutionDecisionAttributes: &workflow.CompleteWorkflowExecutionDecisionAttributes{
			Result_: workflowResult,
		},
	}}

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err, string(history))
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(14), info.nextEventID)
	s.Equal(decisionStartedEvent2.GetEventId(), info.lastProcessedEvent)
	s.Equal(context, info.executionContext)
	s.Equal(workflowStateRunning, info.state)

	completedEvent := updatedBuilder.GetEvent(12)
	s.Equal(decisionScheduledEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(decisionStartedEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	attributes := updatedBuilder.GetEvent(13).GetCompleteWorkflowExecutionFailedEventAttributes()
	s.Equal(workflow.WorkflowCompleteFailedCause_UNHANDLED_DECISION, attributes.GetCause())
	s.Equal(completedEvent.GetEventId(), attributes.GetDecisionTaskCompletedEventId())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedFailWorkflowFailed() {
	tl := "testTaskList"
	identity := "testIdentity"
	context := []byte("context")
	activity1ID := "activity1"
	activity1Type := "activity_type1"
	activity1Input := []byte("input1")
	activity1Result := []byte("activity1_result")
	activity2ID := "activity2"
	activity2Type := "activity_type2"
	activity2Input := []byte("input2")
	reason := "workflow fail reason"
	details := []byte("workflow fail details")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 25, 200, identity)
	decisionScheduledEvent1 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent1 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent1.GetEventId(), tl, identity)
	decisionCompletedEvent1 := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent1.GetEventId(),
		decisionStartedEvent1.GetEventId(), nil, identity)
	activity1ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity1ID,
		activity1Type, tl, activity1Input, 100, 10, 5)
	activity2ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity2ID,
		activity2Type, tl, activity2Input, 100, 10, 5)
	activity1StartedEvent := addActivityTaskStartedEvent(builder, activity1ScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskStartedEvent(builder, activity2ScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskCompletedEvent(builder, activity1ScheduledEvent.GetEventId(),
		activity1StartedEvent.GetEventId(), activity1Result, identity)
	decisionScheduledEvent2 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent2 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent2.GetEventId(), tl, identity)

	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: decisionScheduledEvent2.GetEventId(),
	})

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_FailWorkflowExecution),
		FailWorkflowExecutionDecisionAttributes: &workflow.FailWorkflowExecutionDecisionAttributes{
			Reason:  &reason,
			Details: details,
		},
	}}

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err, string(history))
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(14), info.nextEventID)
	s.Equal(decisionStartedEvent2.GetEventId(), info.lastProcessedEvent)
	s.Equal(context, info.executionContext)
	s.Equal(workflowStateRunning, info.state)

	completedEvent := updatedBuilder.GetEvent(12)
	s.Equal(decisionScheduledEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(decisionStartedEvent2.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	attributes := updatedBuilder.GetEvent(13).GetCompleteWorkflowExecutionFailedEventAttributes()
	s.Equal(workflow.WorkflowCompleteFailedCause_UNHANDLED_DECISION, attributes.GetCause())
	s.Equal(completedEvent.GetEventId(), attributes.GetDecisionTaskCompletedEventId())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedSingleActivityScheduledDecision() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"
	context := []byte("context")
	input := []byte("input")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	startedEvent := addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_ScheduleActivityTask),
		ScheduleActivityTaskDecisionAttributes: &workflow.ScheduleActivityTaskDecisionAttributes{
			ActivityId:   common.StringPtr("activity1"),
			ActivityType: &workflow.ActivityType{Name: common.StringPtr("activity_type1")},
			TaskList:     &workflow.TaskList{Name: &tl},
			Input:        input,
			ScheduleToCloseTimeoutSeconds: common.Int32Ptr(100),
			ScheduleToStartTimeoutSeconds: common.Int32Ptr(10),
			StartToCloseTimeoutSeconds:    common.Int32Ptr(50),
			HeartbeatTimeoutSeconds:       common.Int32Ptr(5),
		},
	}}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err)
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(6), info.nextEventID)
	s.Equal(int64(3), info.lastProcessedEvent)
	s.Equal(context, info.executionContext)

	completedEvent := updatedBuilder.GetEvent(4)
	s.Equal(scheduleEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(startedEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	activity1Attributes := updatedBuilder.GetEvent(5).GetActivityTaskScheduledEventAttributes()
	s.Equal("activity1", activity1Attributes.GetActivityId())
	s.Equal("activity_type1", activity1Attributes.GetActivityType().GetName())
	s.Equal(completedEvent.GetEventId(), activity1Attributes.GetDecisionTaskCompletedEventId())
	s.Equal(tl, activity1Attributes.GetTaskList().GetName())
	s.Equal(input, activity1Attributes.GetInput())
	s.Equal(int32(100), activity1Attributes.GetScheduleToCloseTimeoutSeconds())
	s.Equal(int32(10), activity1Attributes.GetScheduleToStartTimeoutSeconds())
	s.Equal(int32(50), activity1Attributes.GetStartToCloseTimeoutSeconds())
	s.Equal(int32(5), activity1Attributes.GetHeartbeatTimeoutSeconds())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedCompleteWorkflowSuccess() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"
	context := []byte("context")
	workflowResult := []byte("success")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	startedEvent := addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_CompleteWorkflowExecution),
		CompleteWorkflowExecutionDecisionAttributes: &workflow.CompleteWorkflowExecutionDecisionAttributes{
			Result_: workflowResult,
		},
	}}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockExecutionMgr.On("DeleteWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err)
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(6), info.nextEventID)
	s.Equal(int64(3), info.lastProcessedEvent)
	s.Equal(context, info.executionContext)

	completedEvent := updatedBuilder.GetEvent(4)
	s.Equal(scheduleEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(startedEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	workflowCompletedAttributes := updatedBuilder.GetEvent(5).GetWorkflowExecutionCompletedEventAttributes()
	s.Equal(workflowResult, workflowCompletedAttributes.GetResult_())
	s.Equal(completedEvent.GetEventId(), workflowCompletedAttributes.GetDecisionTaskCompletedEventId())
}

func (s *engineSuite) TestRespondDecisionTaskCompletedFailWorkflowSuccess() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"
	context := []byte("context")
	details := []byte("fail workflow details")
	reason := "fail workflow reason"

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	scheduleEvent := addDecisionTaskScheduledEvent(builder, tl, 100)
	startedEvent := addDecisionTaskStartedEvent(builder, scheduleEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	decisions := []*workflow.Decision{{
		DecisionType: workflow.DecisionTypePtr(workflow.DecisionType_FailWorkflowExecution),
		FailWorkflowExecutionDecisionAttributes: &workflow.FailWorkflowExecutionDecisionAttributes{
			Reason:  &reason,
			Details: details,
		},
	}}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()
	s.mockExecutionMgr.On("DeleteWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondDecisionTaskCompleted(&workflow.RespondDecisionTaskCompletedRequest{
		TaskToken:        taskToken,
		Decisions:        decisions,
		ExecutionContext: context,
		Identity:         &identity,
	})
	s.Nil(err)
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(6), info.nextEventID)
	s.Equal(int64(3), info.lastProcessedEvent)
	s.Equal(context, info.executionContext)

	completedEvent := updatedBuilder.GetEvent(4)
	s.Equal(scheduleEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetScheduledEventId())
	s.Equal(startedEvent.GetEventId(), completedEvent.GetDecisionTaskCompletedEventAttributes().GetStartedEventId())
	s.Equal(context, completedEvent.GetDecisionTaskCompletedEventAttributes().GetExecutionContext())
	s.Equal(identity, completedEvent.GetDecisionTaskCompletedEventAttributes().GetIdentity())

	attributes := updatedBuilder.GetEvent(5).GetWorkflowExecutionFailedEventAttributes()
	s.Equal(reason, attributes.GetReason())
	s.Equal(details, attributes.GetDetails())
	s.Equal(completedEvent.GetEventId(), attributes.GetDecisionTaskCompletedEventId())
}

func (s *engineSuite) TestRespondActivityTaskCompletedInvalidToken() {
	invalidToken, _ := json.Marshal("bad token")
	identity := "testIdentity"

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: invalidToken,
		Result_:   nil,
		Identity:  &identity,
	})

	s.NotNil(err)
	s.IsType(&workflow.BadRequestError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskCompletedIfNoExecution() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, &workflow.EntityNotExistsError{}).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskCompletedIfGetExecutionFailed() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, errors.New("FAILED")).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondActivityTaskCompletedUpdateExecutionFailed() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	activityResult := []byte("activity result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(errors.New("FAILED")).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activityResult,
		Identity:  &identity,
	})
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondActivityTaskCompletedIfTaskCompleted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	activityResult := []byte("activity result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	activityStartedEvent := addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskCompletedEvent(builder, activityScheduledEvent.GetEventId(), activityStartedEvent.GetEventId(),
		activityResult, identity)
	addDecisionTaskScheduledEvent(builder, tl, 200)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activityResult,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskCompletedIfTaskNotStarted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	activityResult := []byte("activity result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)

	history, _ := builder.Serialize()
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activityResult,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskCompletedConflictOnUpdate() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activity1ID := "activity1"
	activity1Type := "activity_type1"
	activity1Input := []byte("input1")
	activity1Result := []byte("activity1_result")
	activity2ID := "activity2"
	activity2Type := "activity_type2"
	activity2Input := []byte("input2")
	activity2Result := []byte("activity2_result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 25, 200, identity)
	decisionScheduledEvent1 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent1 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent1.GetEventId(), tl, identity)
	decisionCompletedEvent1 := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent1.GetEventId(),
		decisionStartedEvent1.GetEventId(), nil, identity)
	activity1ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity1ID,
		activity1Type, tl, activity1Input, 100, 10, 5)
	activity2ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity2ID,
		activity2Type, tl, activity2Input, 100, 10, 5)
	activity1StartedEvent := addActivityTaskStartedEvent(builder, activity1ScheduledEvent.GetEventId(), tl, identity)
	activity2StartedEvent := addActivityTaskStartedEvent(builder, activity2ScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info1 := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse1 := &getWorkflowExecutionResponse{
		executionInfo: info1,
	}

	addActivityTaskCompletedEvent(builder, activity2ScheduledEvent.GetEventId(),
		activity2StartedEvent.GetEventId(), activity2Result, identity)
	addDecisionTaskScheduledEvent(builder, tl, 200)
	history2, _ := builder.Serialize()
	info2 := &workflowExecutionInfo{"wId", "rId", tl, history2, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse2 := &getWorkflowExecutionResponse{
		executionInfo: info2,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse1, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse2, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activity1Result,
		Identity:  &identity,
	})
	s.Nil(err, string(history))
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info2)
	s.Equal(int64(12), info2.nextEventID)
	s.Equal(int64(3), info2.lastProcessedEvent)

	completedEvent := updatedBuilder.GetEvent(11)
	s.Equal(workflow.EventType_ActivityTaskCompleted, completedEvent.GetEventType())
	attributes := completedEvent.GetActivityTaskCompletedEventAttributes()
	s.Equal(activity1ScheduledEvent.GetEventId(), attributes.GetScheduledEventId())
	s.Equal(activity1StartedEvent.GetEventId(), attributes.GetStartedEventId())
	s.Equal(activity1Result, attributes.GetResult_())
	s.Equal(identity, attributes.GetIdentity())
}

func (s *engineSuite) TestRespondActivityTaskCompletedMaxAttemptsExceeded() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	activityResult := []byte("activity result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	for i := 0; i < conditionalRetryCount; i++ {
		info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			decisionStartedEvent.GetEventId(), time.Time{}, true}
		wfResponse := &getWorkflowExecutionResponse{
			executionInfo: info,
		}
		s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
		s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	}

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activityResult,
		Identity:  &identity,
	})
	s.Equal(errMaxAttemptsExceeded, err)
}

func (s *engineSuite) TestRespondActivityTaskCompletedSuccess() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	activityResult := []byte("activity result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	activityStartedEvent := addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondActivityTaskCompleted(&workflow.RespondActivityTaskCompletedRequest{
		TaskToken: taskToken,
		Result_:   activityResult,
		Identity:  &identity,
	})
	s.Nil(err)
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(9), info.nextEventID)
	s.Equal(int64(3), info.lastProcessedEvent)

	completedEvent := updatedBuilder.GetEvent(7)
	s.Equal(workflow.EventType_ActivityTaskCompleted, completedEvent.GetEventType())
	attributes := completedEvent.GetActivityTaskCompletedEventAttributes()
	s.Equal(activityScheduledEvent.GetEventId(), attributes.GetScheduledEventId())
	s.Equal(activityStartedEvent.GetEventId(), attributes.GetStartedEventId())
	s.Equal(activityResult, attributes.GetResult_())
	s.Equal(identity, attributes.GetIdentity())

	decisionEvent := updatedBuilder.GetEvent(8)
	s.Equal(workflow.EventType_DecisionTaskScheduled, decisionEvent.GetEventType())
	decisionAttributes := decisionEvent.GetDecisionTaskScheduledEventAttributes()
	s.Equal(tl, decisionAttributes.GetTaskList().GetName())
	s.Equal(int32(200), decisionAttributes.GetStartToCloseTimeoutSeconds())
}

func (s *engineSuite) TestRespondActivityTaskFailedInvalidToken() {
	invalidToken, _ := json.Marshal("bad token")
	identity := "testIdentity"

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: invalidToken,
		Identity:  &identity,
	})

	s.NotNil(err)
	s.IsType(&workflow.BadRequestError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskFailedIfNoExecution() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, &workflow.EntityNotExistsError{}).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskFailedIfGetExecutionFailed() {
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 2,
	})
	identity := "testIdentity"

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(nil, errors.New("FAILED")).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondActivityTaskFailedUpdateExecutionFailed() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(errors.New("FAILED")).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.EqualError(err, "FAILED")
}

func (s *engineSuite) TestRespondActivityTaskFailedIfTaskCompleted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	failReason := "fail reason"
	details := []byte("fail details")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	activityStartedEvent := addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)
	addActivityTaskFailedEvent(builder, activityScheduledEvent.GetEventId(), activityStartedEvent.GetEventId(),
		failReason, details, identity)
	addDecisionTaskScheduledEvent(builder, tl, 200)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Reason:    &failReason,
		Details:   details,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskFailedIfTaskNotStarted() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)

	history, _ := builder.Serialize()
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			emptyEventID, time.Time{}, true},
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.NotNil(err)
	s.IsType(&workflow.EntityNotExistsError{}, err)
}

func (s *engineSuite) TestRespondActivityTaskFailedConflictOnUpdate() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activity1ID := "activity1"
	activity1Type := "activity_type1"
	activity1Input := []byte("input1")
	failReason := "fail reason"
	details := []byte("fail details.")
	activity2ID := "activity2"
	activity2Type := "activity_type2"
	activity2Input := []byte("input2")
	activity2Result := []byte("activity2_result")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 25, 200, identity)
	decisionScheduledEvent1 := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent1 := addDecisionTaskStartedEvent(builder, decisionScheduledEvent1.GetEventId(), tl, identity)
	decisionCompletedEvent1 := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent1.GetEventId(),
		decisionStartedEvent1.GetEventId(), nil, identity)
	activity1ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity1ID,
		activity1Type, tl, activity1Input, 100, 10, 5)
	activity2ScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent1.GetEventId(), activity2ID,
		activity2Type, tl, activity2Input, 100, 10, 5)
	activity1StartedEvent := addActivityTaskStartedEvent(builder, activity1ScheduledEvent.GetEventId(), tl, identity)
	activity2StartedEvent := addActivityTaskStartedEvent(builder, activity2ScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info1 := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse1 := &getWorkflowExecutionResponse{
		executionInfo: info1,
	}

	addActivityTaskCompletedEvent(builder, activity2ScheduledEvent.GetEventId(),
		activity2StartedEvent.GetEventId(), activity2Result, identity)
	addDecisionTaskScheduledEvent(builder, tl, 200)
	history2, _ := builder.Serialize()
	info2 := &workflowExecutionInfo{"wId", "rId", tl, history2, nil, workflowStateRunning, builder.nextEventID,
		decisionStartedEvent1.GetEventId(), time.Time{}, true}
	wfResponse2 := &getWorkflowExecutionResponse{
		executionInfo: info2,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse1, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse2, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Reason:    &failReason,
		Details:   details,
		Identity:  &identity,
	})
	s.Nil(err, string(history))
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info2)
	s.Equal(int64(12), info2.nextEventID)
	s.Equal(int64(3), info2.lastProcessedEvent)

	completedEvent := updatedBuilder.GetEvent(11)
	s.Equal(workflow.EventType_ActivityTaskFailed, completedEvent.GetEventType())
	attributes := completedEvent.GetActivityTaskFailedEventAttributes()
	s.Equal(activity1ScheduledEvent.GetEventId(), attributes.GetScheduledEventId())
	s.Equal(activity1StartedEvent.GetEventId(), attributes.GetStartedEventId())
	s.Equal(failReason, attributes.GetReason())
	s.Equal(details, attributes.GetDetails())
	s.Equal(identity, attributes.GetIdentity())
}

func (s *engineSuite) TestRespondActivityTaskFailedMaxAttemptsExceeded() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	for i := 0; i < conditionalRetryCount; i++ {
		info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
			decisionStartedEvent.GetEventId(), time.Time{}, true}
		wfResponse := &getWorkflowExecutionResponse{
			executionInfo: info,
		}
		s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
		s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(&conditionFailedError{}).Once()
	}

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Identity:  &identity,
	})
	s.Equal(errMaxAttemptsExceeded, err)
}

func (s *engineSuite) TestRespondActivityTaskFailedSuccess() {
	tl := "testTaskList"
	taskToken, _ := json.Marshal(&taskToken{
		WorkflowID: "wId",
		RunID:      "rId",
		ScheduleID: 5,
	})
	identity := "testIdentity"
	activityID := "activity1_id"
	activityType := "activity_type1"
	activityInput := []byte("input1")
	failReason := "failed"
	failDetails := []byte("fail details.")

	builder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	addWorkflowExecutionStartedEvent(builder, "wId", "wType", tl, []byte("input"), 100, 200, identity)
	decisionScheduledEvent := addDecisionTaskScheduledEvent(builder, tl, 30)
	decisionStartedEvent := addDecisionTaskStartedEvent(builder, decisionScheduledEvent.GetEventId(), tl, identity)
	decisionCompletedEvent := addDecisionTaskCompletedEvent(builder, decisionScheduledEvent.GetEventId(),
		decisionStartedEvent.GetEventId(), nil, identity)
	activityScheduledEvent := addActivityTaskScheduledEvent(builder, decisionCompletedEvent.GetEventId(), activityID,
		activityType, tl, activityInput, 100, 10, 5)
	activityStartedEvent := addActivityTaskStartedEvent(builder, activityScheduledEvent.GetEventId(), tl, identity)

	history, _ := builder.Serialize()
	info := &workflowExecutionInfo{"wId", "rId", tl, history, nil, workflowStateRunning, builder.nextEventID,
		emptyEventID, time.Time{}, true}
	wfResponse := &getWorkflowExecutionResponse{
		executionInfo: info,
	}

	s.mockExecutionMgr.On("GetWorkflowExecution", mock.Anything).Return(wfResponse, nil).Once()
	s.mockExecutionMgr.On("UpdateWorkflowExecution", mock.Anything).Return(nil).Once()

	err := s.mockEngine.RespondActivityTaskFailed(&workflow.RespondActivityTaskFailedRequest{
		TaskToken: taskToken,
		Reason:    &failReason,
		Details:   failDetails,
		Identity:  &identity,
	})
	s.Nil(err)
	updatedBuilder := newHistoryBuilder(bark.NewLoggerFromLogrus(log.New()))
	updatedBuilder.loadExecutionInfo(info)
	s.Equal(int64(9), info.nextEventID)
	s.Equal(int64(3), info.lastProcessedEvent)

	completedEvent := updatedBuilder.GetEvent(7)
	s.Equal(workflow.EventType_ActivityTaskFailed, completedEvent.GetEventType())
	attributes := completedEvent.GetActivityTaskFailedEventAttributes()
	s.Equal(activityScheduledEvent.GetEventId(), attributes.GetScheduledEventId())
	s.Equal(activityStartedEvent.GetEventId(), attributes.GetStartedEventId())
	s.Equal(failReason, attributes.GetReason())
	s.Equal(failDetails, attributes.GetDetails())
	s.Equal(identity, attributes.GetIdentity())

	decisionEvent := updatedBuilder.GetEvent(8)
	s.Equal(workflow.EventType_DecisionTaskScheduled, decisionEvent.GetEventType())
	decisionAttributes := decisionEvent.GetDecisionTaskScheduledEventAttributes()
	s.Equal(tl, decisionAttributes.GetTaskList().GetName())
	s.Equal(int32(200), decisionAttributes.GetStartToCloseTimeoutSeconds())
}

func addWorkflowExecutionStartedEvent(builder *historyBuilder, workflowID, workflowType, taskList string, input []byte,
	executionStartToCloseTimeout, taskStartToCloseTimeout int32, identity string) *workflow.HistoryEvent {
	e := builder.AddWorkflowExecutionStartedEvent(&workflow.StartWorkflowExecutionRequest{
		WorkflowId:   common.StringPtr(workflowID),
		WorkflowType: &workflow.WorkflowType{Name: common.StringPtr(workflowType)},
		TaskList:     &workflow.TaskList{Name: common.StringPtr(taskList)},
		Input:        input,
		ExecutionStartToCloseTimeoutSeconds: common.Int32Ptr(executionStartToCloseTimeout),
		TaskStartToCloseTimeoutSeconds:      common.Int32Ptr(taskStartToCloseTimeout),
		Identity:                            common.StringPtr(identity),
	})

	return e
}

func addDecisionTaskScheduledEvent(builder *historyBuilder, taskList string,
	timeout int32) *workflow.HistoryEvent {
	e := builder.AddDecisionTaskScheduledEvent(taskList, timeout)

	return e
}

func addDecisionTaskStartedEvent(builder *historyBuilder, scheduleID int64,
	taskList, identity string) *workflow.HistoryEvent {
	e := builder.AddDecisionTaskStartedEvent(scheduleID, &workflow.PollForDecisionTaskRequest{
		TaskList: &workflow.TaskList{Name: common.StringPtr(taskList)},
		Identity: common.StringPtr(identity),
	})

	return e
}

func addDecisionTaskCompletedEvent(builder *historyBuilder, scheduleID, startedID int64, context []byte,
	identity string) *workflow.HistoryEvent {
	e := builder.AddDecisionTaskCompletedEvent(scheduleID, startedID, &workflow.RespondDecisionTaskCompletedRequest{
		ExecutionContext: context,
		Identity:         common.StringPtr(identity),
	})

	return e
}

func addActivityTaskScheduledEvent(builder *historyBuilder, decisionCompletedID int64, activityID, activityType,
	taskList string, input []byte, timeout, queueTimeout, hearbeatTimeout int32) *workflow.HistoryEvent {
	e := builder.AddActivityTaskScheduledEvent(decisionCompletedID, &workflow.ScheduleActivityTaskDecisionAttributes{
		ActivityId:   common.StringPtr(activityID),
		ActivityType: &workflow.ActivityType{Name: common.StringPtr(activityType)},
		TaskList:     &workflow.TaskList{Name: common.StringPtr(taskList)},
		Input:        input,
		ScheduleToCloseTimeoutSeconds: common.Int32Ptr(timeout),
		ScheduleToStartTimeoutSeconds: common.Int32Ptr(queueTimeout),
		HeartbeatTimeoutSeconds:       common.Int32Ptr(hearbeatTimeout),
	})

	return e
}

func addActivityTaskStartedEvent(builder *historyBuilder, scheduleID int64,
	taskList, identity string) *workflow.HistoryEvent {
	e := builder.AddActivityTaskStartedEvent(scheduleID, &workflow.PollForActivityTaskRequest{
		TaskList: &workflow.TaskList{Name: common.StringPtr(taskList)},
		Identity: common.StringPtr(identity),
	})

	return e
}

func addActivityTaskCompletedEvent(builder *historyBuilder, scheduleID, startedID int64, result []byte,
	identity string) *workflow.HistoryEvent {
	e := builder.AddActivityTaskCompletedEvent(scheduleID, startedID, &workflow.RespondActivityTaskCompletedRequest{
		Result_:  result,
		Identity: common.StringPtr(identity),
	})

	return e
}

func addActivityTaskFailedEvent(builder *historyBuilder, scheduleID, startedID int64, reason string, details []byte,
	identity string) *workflow.HistoryEvent {
	e := builder.AddActivityTaskFailedEvent(scheduleID, startedID, &workflow.RespondActivityTaskFailedRequest{
		Reason:   common.StringPtr(reason),
		Details:  details,
		Identity: common.StringPtr(identity),
	})

	return e
}
